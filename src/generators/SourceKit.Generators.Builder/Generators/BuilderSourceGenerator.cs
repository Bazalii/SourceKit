using FluentChaining;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.DependencyInjection;
using SourceKit.Extensions;
using SourceKit.Generators.Builder.Builders.BuilderTypeBuilders;
using SourceKit.Generators.Builder.Builders.FileBuilders;
using SourceKit.Generators.Builder.Builders.TypeBuilders;
using SourceKit.Generators.Builder.Builders.UsingBuilders;
using SourceKit.Generators.Builder.Commands;
using SourceKit.Generators.Builder.Receivers;
using SourceKit.Generators.Builder.Tools;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace SourceKit.Generators.Builder.Generators;

[Generator]
public class BuilderSourceGenerator : ISourceGenerator
{
    private readonly IChain<FileBuildingCommand, CompilationUnitSyntax> _chain;

    public BuilderSourceGenerator()
    {
        var collection = new ServiceCollection();

        collection.AddFluentChaining(x => x.ChainLifetime = ServiceLifetime.Singleton)
            .AddChain<FileBuildingCommand, CompilationUnitSyntax>
            (
                start => start
                    .Then<UsingBuilder>()
                    .Then<PropertyTypesUsingBuilder>()
                    .Then<TypeBuilder>()
                    .FinishWith((r, _) => r.CompilationUnit)
            )
            .AddChain<TypeBuildingCommand, TypeDeclarationSyntax>
            (
                start => start
                    .Then<BuildMethodTypeBuilder>()
                    .Then<BuilderTypeBuilder>()
                    .FinishWith((r, _) => r.Syntax)
            )
            .AddChain<UsingBuildingCommand, UsingDirectiveSyntax>
            (
                start => start
                    .Then<AutoGeneratedCommentBuilder>()
                    .FinishWith((r, _) => r.Syntax)
            )
            .AddChain<BuilderTypeBuildingCommand, TypeDeclarationSyntax>
            (
                start => start
                    .Then<FieldBuilderTypeBuilder>()
                    .Then<ConstructorBuilderTypeBuilder>()
                    .Then<CollectionMethodBuilderTypeBuilder>()
                    .Then<ValueMethodBuilderTypeBuilder>()
                    .Then<BuildMethodBuilderTypeBuilder>()
                    .FinishWith((r, _) => r.BuilderSyntax)
            );

        var provider = collection.BuildServiceProvider();

        _chain = provider.GetRequiredService<IChain<FileBuildingCommand, CompilationUnitSyntax>>();
    }

    public static string GetFileName(string typeName)
    {
        return $"{typeName}.{Constants.FilenameSuffix}";
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new BuilderAttributeSyntaxContextReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        context.CancellationToken.ThrowIfCancellationRequested();

        if (context.SyntaxContextReceiver is not BuilderAttributeSyntaxContextReceiver receiver)
            return;

        Exception?[] exceptions = receiver.TypeSymbols
            .AsParallel()
            .Select(x => GenerateForType(context, x))
            .ToArray();

        Exception[] notNullExceptions = exceptions.WhereNotNull().ToArray();

        if (notNullExceptions.Length is not 0)
            throw new AggregateException(notNullExceptions);
    }

    private Exception? GenerateForType(GeneratorExecutionContext context, INamedTypeSymbol symbol)
    {
        try
        {
            var fileCommand = new FileBuildingCommand(
                context,
                CompilationUnit(),
                symbol);

            var compilationUnit = _chain.Process(fileCommand);
            var fileName = GetFileName(symbol.Name);

            context.AddSource(fileName, compilationUnit.NormalizeWhitespace().ToFullString().Replace("\r\n", "\n"));

            return null;
        }
        catch (Exception e)
        {
            return e;
        }
    }
}